use heck::ToLowerCamelCase;
use std::{
    fs::{self, File},
    io::{self, Write},
    path::{Path, PathBuf},
};

use specta::{function::FunctionDataType, ts, TypeDefs};

pub fn export_to_js(
    (function_types, _): (Vec<FunctionDataType>, TypeDefs),
    export_path: impl AsRef<Path>,
) -> Result<(), io::Error> {
    let export_path = PathBuf::from(export_path.as_ref());

    if let Some(export_dir) = export_path.parent() {
        fs::create_dir_all(export_dir)?;
    }

    let mut file = File::create(export_path)?;

    write!(
        file,
        r#"// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

const invoke = window.__TAURI_INVOKE__;
"#
    )?;

    for function in function_types {
        let name = &function.name;
        let name_camel = function.name.to_lower_camel_case();

        let arg_list = function
            .args
            .iter()
            .map(|(name, _)| name.to_lower_camel_case())
            .collect::<Vec<_>>();

        let arg_defs = arg_list.join(", ");

        let arg_usages = arg_list
            .is_empty()
            .then(Default::default)
            .unwrap_or_else(|| format!(", {{ {} }}", arg_list.join(", ")));

        let arg_jsdocs = function
            .args
            .iter()
            .map(|(name, typ)| {
                let typ = ts::datatype(typ);
                let name = name.to_lower_camel_case();

                format!("\n * @param {{ {typ} }} {name}")
            })
            .collect::<Vec<_>>()
            .join("\n");

        let ret_type = ts::datatype(&function.result);

        write!(
            file,
            r#"
/** {arg_jsdocs}
 * @returns {{ Promise<{ret_type}> }}
 */
export function {name_camel}({arg_defs}) {{
    return invoke("{name}"{arg_usages})
}}"#
        )?;
    }

    Ok(())
}
